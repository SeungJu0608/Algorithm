### < 1로 만들기 > ###
# 정수 x에 대해 사용할 수 있는 연산은 다음의 4가지 이다.
#   1. x가 5로 나누어떨어지면 5로 나눈다.
#   2. x가 3으로 나누어떨어지면 3으로 나눈다.
#   3. x가 2로 나누어떨어지면 2로 나눈다.
#   4. x에서 1을 뺀다.
# 정수 x가 주어졌을 떄 연산 4개를 적절히 사용해서 1로 만든다.
# 이때 연산을 사용하는 횟수의 최솟값을 출력한다.

# 문제의 점화식
# a(i) = min(a(i-1), a(i/2), a(i/3), a(i/5)) + 1  # 함수의 호출 횟수로 인해 +1

# 데이터 입력
x = int(input())
# 다이나믹 프로그래밍
# 메모리 초기화
dp = [0]*30001
# bottom-up
for i in range(2, x + 1):
    # a(i-1)의 경우 함수 호출 횟수
    dp[i] = dp[i-1] + 1
    # a(i/2)의 경우 함수 호출 횟수와 비교
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)
    # a(i/3)의 경우 함수 호출 횟수와 비교
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1)
    # a(i/5)의 경우 함수 호출 횟수와 비교
    if i % 5 == 0:
        dp[i] = min(dp[i], dp[i//5] + 1)

print(dp[x])



### < 개미 전사 > ###

# 부족한 식량을 충당하고자 개미 전사가 여러개의 식량창고가 일직선으로 연결된 메뚜기 마을의 식량창고를 공격하려고 한다.
# 각 식량창고는 정해진 수의 식량을 저장하고 있으며 개미 전사는 선택적으로 약탈할 예정이다.

# 데이터 입력
# n : 식량창고의 개수  /  k : 각 식량창고에 저장된 식량의 개수
n = int(input())
k = list(map(int, input().split()))

# 다이나믹 프로그래밍
# 점화식 이용하기
# 왼쪽부터 차례대로 식량창고를 털지 안 털지를 결정하는 경우와 i번째 창고를 털지에 대한 여부를 결정할때
#  1) i-1번째를 턴다고 결정할 때 : i번째 창고를 털 수 없음
#  2) i-2번째를 턴다고 결정할 떄 : i번째 창고를 털 수 있음
# 따라서 a(i) = max(a(i-1), a(i-2)+k[i])

# dp table
dp = [0]*(n+1)
# 수열의 초기값
dp[1] = k[0]
dp[2] = max(k[0], k[1])
# bottom-up
for i in range(3, n+1):
    dp[i] = max(dp[i-1], dp[i-2]+k[i])

print(dp[n])



### < 바닥 공사 > ###
# 가로길이 : N  /  세로길이 : 2
# 타일 종류 : (1*2), (2*1), (2*2)
# 바닥을 채우는 모든 경우의 수를 구하는 프로그램 작성하기
# 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.

# 데이터 입력
n = int(input())

# 다이나믹 프로그래밍
# 점화식 이용하기
# 왼쪽부터 차례대로 바닥을 타일로 채운다고 생각하자.
# 가장 오른쪽에 채우는 방법
#  1) (2*1)로 채울 떄 : 가장 왼쪽부터 i-1까지 타일을 채우는 경우의 수로 가로 i까지의 바닥을 채우는 방법이 존재한다.
#  2) (1*2)*2 로 채울 때 : 가장 왼쪽부터 i-2까지 타일을 채우는 경우의 수로 방법이 존재한다.
#  3) (2*2)로 채울 때 : 2)번의 경우와 동일하다.
# 따라서 점화식은 다음과 같다.
# a(i) = a(i-1) + a(i-2)*2

# dp table
d = [0]*1001        # 1<=n<=1000
# 점화식의 초기값
d[1] = 1
d[2] = 3
# bottom-up
for i in range(3, n+1):
    d[i] = (d[i-1] + d[i-2]*2)%796796

print(d[n])





### < 효율적인 화폐 구성> ###
# n가지 종류의 화폐가 있다.
# 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 m원이 되도록 한다.
# 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.

# 그리디 알고리즘의 거스름돈 문제와 비슷한 문제.
# 그러나 n가지 종류의 화폐 중 큰 단위가 작은 단위의 배수가 아니라는 것만 다름.

# 특정 금액까지 최소한의 화폐를 구성하는 작업은 각각 동일하다.
# 적은 금액부터 큰 금액까지 차례로 만들 수 있는 최소한의 화폐 개수를 찾는다.
# 따라서 다이나믹 프로그래밍을 이용한다.

# 점화식
# 1<=n<=100  /  1<=m<=10,000
# a(i) : 금액 i까지 만들 수 있는 최소한의 화폐개수  /   k : 화폐단위
# a(i) =   1) a(i-k)를 만들 수 있는 경우 : min(a(i-k) + 1, a(i))
#          2) a(i-k)를 만들 수 없는 경우 : '만들 수 없음'

# 데이터 입력
n, m = map(int, input().split())
money = []
for i in range(n):
    money[i] = int(input())

# dp table 초기화
# 금액 i까지 만들 수 있는 최소한의 화폐개수
dp = [10001] * (10000+1)     # 10001은 m의 최대값을 넘은 값으로 금액 i를 구성할 수 없다는 뜻이다.
                     # 화폐단위는 10,000을 넘지 않므로 max(m)을 구성할 수 있는 최대 화폐 개수는 10,000개이다.

# 초기값
dp[0] = 0       # 0원은 아무것도 이용하지 않는 하나의 경우가 있다.

# 다이나믹 프로그래밍
# 각 단위 화폐마다, 왼쪽부터 차례로
# bottom-up
for i in money:
    dp[i] = 1
    for j in range(i+1, m+1):
        if dp[j-i] != 10001:
            dp[j] = min(dp[j-i] + 1, dp[j])

# 불가능할때는 -1을 출력
if dp[m] == 10001:
    print(-1)
else:
    print(dp[m])


