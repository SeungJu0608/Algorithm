### [ 동적 계획법 ]
# 메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시킬 수 있는 방법 중 하나
# 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘
## cf) 자료구조의 동적 할당 (dynamic allocation)
##      : 프로그램 실행 중에 실행에 필요한 메모리를 할당하는 기법

## 피보나치 수열 구현하기
# 점화식 : a(n) = a(n-1) + a(n-2), n >= 3, a(1) = a(2) = 1
# 1) 재귀함수 이용하기
def fibo_re(n) :
    if n == 1 or n == 2:
        return 1
    return fibo_re(n-1) + fibo_re(n-2)

# 그러나 재귀함수를 이용하면 수행했던 계산을 계속 반복적으로 시행하게되어 n이 증가하면 running time이 비약적으로 커진다.
# 따라서 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다.
# 다만 다음과 같은 조건을 만족하는 경우 다이나믹 프로그래밍을 적용할 수 있다.
#   *조건*  :  1. 큰 문제를 작은 문제로 나눌 수 있다.
#             2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

# 2) 메모이제이션(memoization)
#    : - 다이나믹 프로그래밍을 구현하는 방법 중 하나
#      - 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법

# Top-down 방식
#       : 재귀 함수를 이용
# 메모를 위한 리스트 초기화
memo = [0]*100
# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo_td(n):
    if n == 1 or n ==2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if memo[n] != 0:
        return memo[n]
    # 아직 계산하지 않은 문제라면 점화식에 따라 피보나치 결과 반환하고 메모까지
    memo[n] = fibo_td(n-1) + fibo_td(-2)
    return memo[n]

# 그러나 재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라가야 하므로
# 부가적인 시간인 오버헤드가 발생할 수 있다. 따라서 재귀함수 대신 반복문을 사용하여 오버헤드를 줄일 수 있다.

# 3) Bottom-up 방식
#    : 단순히 반복문을 이용
# 메모리 리스트 초기화
memo = [0]*100
# 피보나치 수열의 초기값 할당
memo[1] = 1
memo[2] = 1
n = 99
# 피보나치 함수
for i in range(3, n+1):
    memo[i] = memo[i-1] + memo[i-2]

print(memo[n])

